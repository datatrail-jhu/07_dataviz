[["index.html", "07: Data Visualization About this Course", " 07: Data Visualization June, 2022 About this Course This course is part of a series of courses for DataTrail. DataTrail is a no-cost, paid 14-week educational initiative for young-adult, high school and GED-graduates. DataTrail aims to equip members of underserved communities with the necessary skills and support required to work in the booming field of data science. DataTrail is a fresh take on workforce development that focuses on training both Black, Indigenous, and other people of color (BIPOC) interested in the data science industry and their potential employers. Offered by the Johns Hopkins Bloomberg School of Public Health, in partnership with local non-profits and Leanpub, DataTrail combines a mutually-intensive learning experience (MILE) with a whole-person ecosystem of support to allow aspiring data scientists and their employers to succeed. DataTrail uses mutually-intensive learning DataTrail joins aspiring data science scholars and expert-level data scientist mentors in a mutually-intensive learning experience (MILE). In the DataTrail MILE: Scholars engage in cutting-edge technical and soft skills training needed to enter the data science field. Mentors engage in anti-racism and mentorship training needed to be impactful mentors and informed colleagues on diverse data science teams. The social connections created along the way will fuel job opportunities for scholars and foster a more diverse, equitable, and inclusive climate at the mentors’ institutions. "],["intro-to-data-visualization.html", "Chapter 1 Intro to Data Visualization", " Chapter 1 Intro to Data Visualization Data visualization is an incredibly important part of any data science project. When you are first handed a data set by your boss or first scrape a large dataset from the Internet, visualizing your data can help you get a handle on what’s going on in the data set. Similarly, once you’ve done your analysis and are ready to communicate your findings to your teammates, data visualizations are an effective way to communicate your results to others. In this lesson, we’ll walk through what data visualization is and define some of the basic types of data visualizations. 1.0.1 Data Visualization At its core, the term ‘data visualization’ refers to any visual display of data that helps us understand the underlying data better. This can be a plot or figure of some sort or a table that summarizes the data. Generally, there are a few characteristics of all good plots. 1.0.1.1 General Features of Plots Good plots have a number of features. While not exhaustive, good plots have: 1. Clearly-labeled axes. 2. Text that are large enough to see. 3. Axes that are not misleading. 4. Data that are displayed appropriately considering the type of data you have. More specifically, however, there are two general approaches to data visualization: exploratory plots and explanatory plots. 1.0.1.2 Exploratory Plots These are data displays to help you better understand and discover hidden patterns in the data you’re working with. These won’t be the prettiest plots, but they will be incredibly helpful. Exploratory visualizations have a number of general characteristics: They are made quickly. You’ll make a large number of them. The axes and legends are cleaned up. Below we have a graph where the axes are labeled and general pattern can be determined. This is a great example of an exploratory plot. It lets you the analyst know what’s going on in your data, but it isn’t yet ready for a big presentation. Exploratory Plot As you’re trying to understand the data you have on hand, you’ll likely make a lot of plots and tables just to figure out to explore and understand the data. Because there are a lot of them and they’re for your use (rather than for communicating with others), you don’t have to spend all your time making them perfect. But, you do have to spend enough time to make sure that you’re drawing the right conclusions from this. Thus, you don’t have to spend a long time considering what colors are perfect on these, but you do want to make sure your axis are not cut off. Other Exploratory Plotting Examples 1.0.2 Explanatory Plots These are data displays that aim to communicate insights to others. These are plots that you spend a lot of time making sure they’re easily interpretable by an audience. General characteristics of explanatory plots: They take a while to make. There are only a few of these for each project. You’ve spent a lot of time making sure the colors, labels, and sizes are all perfect for your needs. Here we see an improvement upon the exploratory plot we looked at previously. Here, the axis labels are more descriptive. All of the text is larger. The legend has been moved onto the plot. The points on the plot are larger. And, there is a title. All of these changes help to improve the plot, making it an explanatory plot that would be presentation-ready. Explanatory Plots Explanatory plots are made after you’ve done an analysis and once you really understand the data you have. The goal of these plots is to communicate your findings clearly to others. To do so, you want to make sure these plots are made carefully - the axis labels should all be clear, the labels should all be large enough to read, the colors should all be carefully chosen, etc.. As this takes times and because you do not want to overwhelm your audience, you only want to have a few of these for each project. We often refer to these as “publication ready” plots. These are the plots that would make it into an article at the New York Times or in your presentation to your bosses. Other Explanatory Plotting Examples: How the Recession Shaped the Economy (NYT) 2018 Flue Season (FiveThirtyEight) 1.0.3 Types of Plots Above we saw data displayed as both an exploratory plot and an explanatory plot. That plot was an example of a scatterplot. However, there are many types of plots that are helpful. We’ll discuss a few basic ones below and will include links to a few galleries where you can get a sense of the many different types of plots out there. To do this, we’ll use the “Davis” dataset which includes, height and weight information for 200 people. Data Set 1.0.3.1 Histogram Histograms are helpful when you want to better understand what values you have in your data set for a single set of numbers. For example, if you had a dataset with information about many people, you may want to know how tall the people in your data set are. To quickly visualize this, you could use a histogram. Histograms let you know what range of values you have in your data set. For example, below you can see that in this data set, the height values range from around 50 to around 200 cm. The shape of the histogram also gives you information about the individuals in your dataset. The number of people at each height are also counted. So, the tallest bars show that there are about 40 people in the data set whose height is between 165 and 170 cm. Finally, you can quickly tell, at a glance that most people in this data set are at least 150 cm tall, but that there is at least one individually whose reported height is much lower. Histogram 1.0.3.2 Scatterplot Scatterplots are helpful when you have numerical values for two different pieces of information and you want to understand the relationship between those pieces of information. Here, each dot represents a different person in the data set. The dot’s position on the graph represents that individual’s height and weight. Overall, in this data set, we can see that, in general, the more someone weighs, the taller they are. Scatterplots, therefore help us at a glance better understand the relationship between two sets of numbers. Scatter Plot 1.0.3.3 Barplot When you only have one numerical piece of information and a second piece of information that can be broken down into a few categories, a barplot will help you make numerical comparisons across categories. For example if you wanted to look at how many females and how many males you have in your data set, you could use a barplot. The comparison in heights between bars clearly demonstrates that there are more females in this dataset than males. Barplot 1.0.3.4 Boxplot The final basic plot we’ll talk about here is the boxplot. Boxplots also summarize numerical values across a category; however, instead of just comparing the heights of the bar, they give us an idea of the range of values that each category can take. For example, if we wanted to compare the heights of men to the heights of women, we could do that with a boxplot. Boxplot To interpret a boxplot, there are a few places where we’ll want to focus our attention. For each category, the horizontal line through the middle of the box corresponds to the median value for that group. So, here, we can say that the median, or most typical height for females is about 165 cm. For males, this value is higher, just under 180 cm. Outside of the colored boxes, there are dashed lines. The ends of these lines correspond to the typical range of values. Here, we can see that females tend to have heights between 150 and 180cm. Lastly, when individuals have values outside the typical range, a boxplot will show these individuals as circles. These circles are referred to as outliers. 1.0.3.5 Resources to look at these and other types of plots: R Graph Gallery Ferdio Data Visualization Catalog 1.0.4 Tables While we have focused on figures here so far, tables can be incredibly informative at a glance too. If you are looking to display summary numbers, a table can also visually display information. Using this same data set, we can use a table to get a quick breakdown of how many males and females there are in the data set and what percentage of each gender there is. A few things to keep in mind when making tables is that it’s best to: Limit the number of digits in the table Include a caption When possible, keep it simple. Table 1.0.5 Slides and Video Intro to Data Visualization Slides "],["good-plots.html", "Chapter 2 Good Plots", " Chapter 2 Good Plots The goal of data visualization in data analysis is to improve understanding of the data. As mentioned in the last lesson, this could mean improving our own understanding of the data or using visualization to improve someone else’s understanding of the data. We discussed some general characteristics and basic types of plots in the last lesson, but here we will step through a number of general tips for making good plots. 2.0.1 Tips for Making Good Plots 2.0.1.1 Choose the right type of plot If your goal is to allow the viewer to compare values across groups, pie charts should largely be avoided. This is because it’s easier for the human eye to differentiate between bar heights than it is between similarly-sized slices of a pie. Thinking about the best way to visualize your data before making the plot is an important step in the process of data visualization. Choose an appropriate plot for the data you’re visualizing. 2.0.1.2 Be mindful when choosing colors Choosing colors that work for the story you’re trying to convey with your visualization is important. Avoiding colors that are hard to see on a screen or when projected, such as pastels, is a good idea. Additionally, red-green color blindness is common and leads to difficulty in distinguishing reds from greens. Simply avoiding making comparisons between these two colors is a good first step when visualizing data. Choosing appropriate colors for visualizations is important Beyond red-green color blindness, there is an entire group of experts out there in color theory.To learn more about available color palettes in R or to read more from a pro named Lisa Charlotte Rost talking about color choices in data visualization, feel free to read more. 2.0.1.3 Label your axes Whether you’re making an exploratory or explanatory visualization, labeled axes are a must. They help tell the story of the figure. Making sure the axes are clearly labeled is also important. Rather than labeling the graph below with “h” and “g,” we chose the labels “height” and “gender,” making it clear to the viewer exactly what is being plotted. Having descriptive labels on your axes is critical 2.0.1.4 Make sure text is readable Often text on plots is too small for viewers to read. By being mindful of the size of the text on your axes, in your legend, and used for your labels, your visualizations will be greatly improved. On the right, we see that the text is easily readable 2.0.1.5 Make sure your numbers add up When you’re making a plot that should sum to 100, make sure that it in fact does. Taking a look at visualizations after you make them to ensure that they make sense is an important part of the data visualization process. At left, the pieces of the pie only add up to 95%. On the right, this error has been fixed and the pieces add up to 100% 2.0.1.6 Make sure the numbers and plots make sense together Another common error is having labels that don’t reflect the underlying graphic. For example, here, we can see on the left that the turquoise piece is more than half the graph, and thus the label 45% must be incorrect. At right, we see that the labels match what we see in the figure. Checking to make sure the numbers and plot make sense together is important 2.0.1.7 Make comparisons easy on viewers There are many ways in which you can make comparisons easier on the viewer. For example, avoiding unnecessary whitespace between the bars on your graph can help viewers make comparisons between the bars on the barplot. At left, there is extra white space between the bars of the plot that should be removed. On the right, we see an improved plot 2.0.1.8 Use y-axes that start at zero Often, in an attempt to make differences between groups look larger than they are, y-axis will be started at a value other than zero. This is misleading. Y-axis for numerical information should start at zero. At left, the differences between the vars appears larger than on the right; however, this is just because the y-axis starts at 200. The proper way to start this graph is to start the y-axis at 0. 2.0.1.9 Keep it simple The goal of data visualization is to improve understanding of data. Sometimes complicated visualizations cannot be avoided; however, when possible, keep it simple. Here, the graphic does not immediately convey a main point. It’s hard to interpret what each circle means or what the story of this graphic is supposed to me. Make sure in your graphics that your main point comes through Similarly, the intention of your graphic should never be to mislead and confuse. Unlike what was done here, be sure that your data visualizations improve viewers’ understanding. Do not aim to confuse 2.0.2 What To Consider When Making Plots Having discussed some general guidelines, there are a number of questions you should ask yourself before making a plot. These have been nicely laid out in a blog post from the wonderful team at Chartable, Datawrapper’s blog. We will summarize them here and include a number of the images from their post. The post argues that there are three main questions you should ask any time you create a visual display of your data. We will discuss these three questions below and then step through the process of creating data displays in R. Three Questions for Creating a Chart What’s your point? How can you emphasize your point in your chart? What does your final chart show exactly? 2.0.2.1 The Data We Want to Plot When discussing data visualization, it’s always good to have an example to look at. For the example here, we’ll use the same example Lisa Charlotte Rost used in her blog post. If you were interested in analyzing data that looked to assess the success of the iPhone, you would want to look at data to see how sales of iPhones have changed over time. You might, for example, start with a super basic plot like this: iPhone Sales over time 2.0.2.2 What’s your point? Whenever you have data you’re trying to plot, think about what you’re actually trying to show. Once you’ve taken a look at your data, a good title for the plot can be helpful. Your title should tell viewers what they’ll see when they look at the plot. For the iPhone example, a reasonable headline would be **“iPhone more successful than all other Apple products.” This tells us what others would expect to conclude from looking at the data in the figure. iPhone Sales over time with title 2.0.2.3 How can you emphasize your point? We talked about it in the last lesson, but an incredibly important decision is that, choosing an appropriate chart for the type of data you have is very important. In the next section of this lesson, we’ll discuss what type of data are appropriate for each type of plot in R; however, for now, we’ll just focus on the iPhone data example. With this example, we’ll discuss that you can emphasize your point by: adding data highlighting data with color annotating your plot 2.0.2.3.1 Adding data With our example data set, our title suggests that the iPhone has been Apple’s most successful product. To make that claim, it would be really helpful for the plot to compare iPhone sales with other Apple products, say, the iPad or the iPod. By adding data about other Apple products over time, we can visualize just how successful the iPhone has been. iPhone Sales over time vs other Apple Products 2.0.2.3.2 Highlighting data with color Colors help direct viewers’ eyes to the most important parts of the figure. Colors tell your readers where to focus their attention. Grays help to tell viewers where to focus less of their attention, while other colors help to highlight the point your trying to make. For example, in the iPhone example, we can de-emphasize the iPod and iPad data using gray lines, while really highlighting the huge amount of growth of the iPhone, by making its line red. iPhone Sales, in red, over time vs other Apple Products, in gray 2.0.2.3.3 Annotate your plot By highlighting parts of your plot with arrows or text on your plot, you can further draw viewers’ attention to certain part of the plot. These are often details that are unnecessary in exploratory plots, where the goal is just to better understand the data, but are very helpful in explanatory plots, when you’re trying to draw conclusions from the plot. In the iPhone example, by highlighting when Apple announced the iPhone 4 in 2010 and adding text to explain that this was the first time that more iPhones were sold than iPods, viewers get a better understanding of the data. iPhone sales over time annotated 2.0.2.4 What does your final chart show? The first step of the process told viewers what they would see in the plot. The second step showed them. The third step makes it extra clear to viewers what they should be seeing. You explain to viewers what they should be seeing in the plot. This is where you are sure to add descriptions, legends, and the source of your data. Again, these are important pieces of creating a complete explanatory plot, but are not all necessary when making exploratory plots. 2.0.2.4.1 Write precise descriptions Whether it’s a figure legend at the bottom of your plot, a subtitle explaining what data are plotted, or clear axes labels, text describing clearly what’s going on in your plot is important. Here, the author of these plots decided to include a subtitle, “Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014.” She could have similarly included this information on the y-axis “Worldwide sales of Apple products (in millions).” While there are different approaches, including this information is critical. iPhone sales over time annotated with description 2.0.2.4.2 Add legends When making a plot, be sure that viewers are able to easily determine what each line or point on a plot represents. Here, by adding text to label which line is iPhone, which is iPad, and which is iPod, viewers are quickly able to understand the plot iPhone sales over time annotated with description and text labels 2.0.2.4.3 Add a source When finalizing an explanatory plot, be sure to source your data. It’s always best for readers to know where you obtained your data and what data are being used to create your plot. Transparency is important. iPhone sales over time with source information The finalized plot is clear, the conclusion the viewer is to make is obvious, the data are well-labeled, and the plot is annotated. Final blog post plot 2.0.3 Making The iPhone Plot in R Here, we’ll introduce the code required to generate the plot used as an example in this lesson in R, but we won’t walk through this code step-by-step until a later lesson. We include this now to make two points: Once you have access to the data, you can manipulate plots to look the way you want. It often takes a lot of somewhat complicated code to reproduce someone else’s beautiful plot. As to the second point above, while the code here is rather complicated, you’ll see that the code required to make basic plots in R is quite simple. Once you master the basics, you’ll be able to start generating more and more complex plots, building on the basic building blocs that we’ll go over in the next lesson! library(ggplot2) library(reshape2) library(zoo) library(directlabels) ## after downloading data from https://blog.datawrapper.de/better-charts/ ## read data into R df &lt;- read.csv(&quot;data-orzoM.csv&quot;,stringsAsFactors=FALSE) ## get quarter year variable into a form R knows how to work with df$Year &lt;- grep(&quot;Q&quot;,unlist(strsplit(as.character(df$Quarter),&quot;\\\\s&quot;)), value=TRUE, invert=TRUE) df$Q &lt;- grep(&quot;Q&quot;,unlist(strsplit(as.character(df$Quarter),&quot;\\\\s&quot;)), value=TRUE, invert=FALSE) df$yrq &lt;- paste(df$Year,df$Q, sep=&quot; &quot;) df$yrq &lt;- as.yearqtr(df$yrq) ## reshape data into long, tidy format df2 &lt;- melt(df, id=c(&quot;Quarter&quot;,&quot;yrq&quot;,&quot;Year&quot;, &quot;Q&quot;)) df2$value &lt;- as.numeric(df2$value) ## plot data as in blog post p &lt;- ggplot(data = df2, aes(x=yrq,y=value, group=variable, color=variable)) + geom_line(size = 1.5) + scale_x_yearqtr(limits = c(2004, 2015), format = &quot;%Y&quot;, breaks=c(2004:2015), expand = c(0.1, 0.01)) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + scale_y_continuous(breaks = c(0,10,20,30,40,50,60,70,80)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text = element_text(size=15), plot.margin = unit(c(1,1,1,1), &quot;lines&quot;), legend.position =&quot;none&quot;, plot.title = element_text(size = 22), plot.subtitle = element_text(size = 15), panel.border = element_blank() ) + geom_dl(aes(label = variable), method = list(c(&quot;last.points&quot;), aes(colour = &quot;black&quot;), cex = 1.3) ) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + annotate(&quot;rect&quot;, xmin = 2010, xmax = 2011, ymin = 0, ymax = Inf, fill = &quot;grey&quot;, alpha = 0.2) + annotate(&quot;text&quot;, x = 2010.5, y = 40, label = &quot;After Apple announced \\n the iPhone 4 in 2010, \\n more iPhones were sold \\n than iPods for the first time.&quot;, hjust = 1, size=6) ## save plot as PNG ggsave(&quot;iPhone_sales.png&quot;,p, width=12 , units=c(&quot;in&quot;)) Reproduced blog post plot While the plots are not identical, they are very similar and tell the same story. Making good plots in R is an important skill and can be learned using the ggplot2 package in R. We’ll discuss how to generate ggplot2 plots in the next lesson! 2.0.4 Additional Resources To learn more about bad plotting techniques to avoid, you can check out Flowing Data’s Ugly Charts or WTF Visualizations. To see examples of beautiful data visualizations, check out Nathan Yau’s Flowing Data blog, the Chartable blog, or many analytical pieces published by FiveThirtyEight. To read more about red-green color blindness, read more information here. To read more about Data Visualization and the goals of Data Visualization read Elijah Meek’s Data Visualization Fast and Slow - links to the rest of the posts in this series are included there. 2.0.5 Slides and Video Good Plots Slides "],["introduction-to-ggplot2.html", "Chapter 3 Introduction to ggplot2", " Chapter 3 Introduction to ggplot2 R was initially developed for statisticians, who often are interested in generating plots or figures to visualize their data. As such, a few basic plotting features were built in when R was first developed. These are all still available; however, over time, a new approach to graphing in R was developed. This new approach implemented what is known as the grammar of graphics, which allows you to develop elegant graphs flexibly in R. Making plots with this set of rules requires the R package ggplot2. To get started using ggplot2 requires you to install and load the package into R. install.packages(&quot;ggplot2&quot;) library(ggplot2) 3.0.1 The basics The grammar of graphics implemented in ggplot2 is based on the idea that you can build any plot as long as you have a few pieces of information. To start building plots in ggplot2, we’ll need some data and to know the type of plot we want to make. The type of plot you want to make in ggplot2 is referred to as a geom. This will get us started, but the idea behind ggplot2 is that every new concept we introduce will be layered on top of the information you’ve already learned. In this way, ggplot2 is layered - layers of information add on top of each other as you build your graph. In code written to generate a ggplot2 figure, you will see each line is separated by a plus sign (+). Think of each line as a different layer of the graph. We’re simply adding one layer on top of the previous layers to generate the graph. You’ll see exactly what we mean by this throughout each section in this lesson. To get started, we’ll start with the two basics (data and a geom) and build additional layers from there. As we get started plotting in ggplot2, plots will take the following general form: ggplot(data = DATASET) + geom_PLOT_TYPE(mapping = aes(VARIABLE(S))) After installation and loading ggplot2 in, you will always begin by calling the ggplot() function. You’ll then specify your dataset. Within the ggplot() function. Then, before making your plot you will also have to specify what geom type you’re interested in plotting. We’ll focus on a few basic geoms in the next section and give examples of each plot type (geom), but for now we’ll just work with a single geom: geom_point. geom_point is most helpful for creating scatterplots. As a reminder from an earlier lesson, scatterplots are useful when you’re looking at the relationship between two numeric variables. Within geom you will specify the arguments needed to tell ggplot2 how you want your plot to look. You will map your variables using the aesthetic argument aes. We’ll walk through examples below to make all of this clear. However, get comfortable with the overall look of the code now. 3.0.2 Example dataset: diamonds To build your first plot in ggplot2 we’ll make use of the fact that there are some datasets already available in R. One frequently-used data set is known as diamonds. This data set contains prices and other attributes of 53,940 diamonds, with each row containing information about a different diamond. If you look at the first few rows of data, you can get an idea of what data are included in this dataset. First 12 rows of diamonds dataset Here you see a lot of numbers and can get an idea of what data are available in this data set. For example, in looking at the column names across the top, you can see that we have information about how many carats each diamond is (carat), some information on the quality of the diamond cut (cut), the color of the diamond from J (worst) to D (best) (color), along with a number of other pieces of information about each diamond. We will use this data set to better understand how to generate plots in R, using ggplot2. 3.0.3 Scatterplots: geom_point In ggplot2 we specify these by defining x and y in the aes() argument. The x argument defines which variable will be along the bottom of the plot. y refers to which variable will be along the left side of the plot. If we wanted to understand the relationship between the number of carats in a diamond and that diamond’s price, we may do the following: ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price)) diamonds scatterplot In this plot, we see that, in general, the larger the diamond is (or the more carats it has), the more expensive the diamond is (price), which is probably what we would have expected. However, now, we have a plot that definitively supports this conclusion. 3.0.4 Aesthetics What if we wanted to alter the size, color or shape of the points? Probably unsurprisingly, these can all be changed within the aesthetics argument. After all, something’s aesthetic refers to how something looks. Thus, if you want to change the look of your graph, you’ll want to play around with the plot’s aesthetics. In fact, in the plots above you’ll notice that we specified what should be on the x and y axis within the aes() call. These are aesthetic mappings too! We were telling ggplot2 what to put on each axis, which will clearly affect how the plot looks, so it makes sense that these calls have to occur within aes(). Additionally now, we’ll focus on arguments within aes() that change how the points on the plot look. 3.0.4.1 Point color In the scatterplot we just generated, we saw that there was a relationship between carat and price, such that the more carats a diamond has, generally, the higher the price. But, it’s not a perfectly linear trend. What we mean by that is that not all diamonds that were 2 carats were exactly the same price. And, not all 3 carat diamonds were exactly the same price. What if we were interested in finding out a little bit more about why this is the case? Well, we could look at the clarity of the diamonds to see whether or not that affects the price of the diamonds? To add clarity to our plot, we could change the color of our points to differ based on clarity: ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price, color = clarity) changing point colors helps us better understand the data Here, we see that not only are the points now colored by clarity, ggplot2 has also automatically added a legend for us with the various classes and their corresponding point color. The Help pages of the diamonds dataset (accessed using ?diamonds) state that clarity is “a measurement of how clear the diamond is.” The documentation also tells us that I1 is the worst clarity and IF is the best (Full scale: I1, SI1, SI2, VS1, VS2, VVS1, VVS2, IF). This makes sense with what we see in the plot. Small (&lt;1 carat) diamonds that have the best clarity level (IF) are some of the most expensive diamonds. While, relatively large diamonds (diamonds between 2 and 3 carats) of the lowest clarity (I1) tend to cost less. By coloring our points by a different variable in the dataset, we now understand our dataset better. This is one of the goals of data visualization! And, specifically, what we’re doing here in ggplot2 is known as mapping a variable to an aesthetic. We took another variable in the dataset, mapped it to a color, and then put those colors on the points in the plot. Well, we only told ggplot2 what variable to map. It took care of the rest! Of course, we can also manually specify the colors of the points on our graph; however, manually specifying the colors of points happens outside of the aes() call. This is because ggplot2 does not have to go through the mapping the variable to an aesthetic process. In the code here, ggplot2 doesn’t have to go through the trouble of figuring out which level of the variable is going to be which color on the plot (the mapping to the aesthetic part of the process). Instead, it just colors every point red. Thus, manually specifying the color of your points happens outside of aes(): ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price), color = &quot;red&quot;) manually specifying point color occurs outside of aes() 3.0.4.2 Point size As above, we can change the point size by mapping another variable to the size argument within aes: ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price, size = clarity)) mapping to size changes point size on plot As above, ggplot2 handles actually doing the mapping. All you have to do is specify what variable you want mapped (clarity) and how you want ggplot2 to handle the mapping (change the point size). With this code, you do get a warning when you run it in R that using a “discrete variable is not advised.” This is because mapping to size is usually done for numeric variables, rather than categorical variables like clarity. This makes sense here too. The relationship between clarity, carat and price was easier to visualize when clarity was mapped to color than here where it is mapped to size. As above, the size of every point can be changed by calling size outside of aes: ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price), size = 4.5) manually specifying point size of all points occurs outside of aes() Here, we have manually increased the size of all the points on the plot. 3.0.4.3 Point Shape You can also change the shape of the points (shape). We’ve used solid, filled circles thus far (the default in geom_point), but we could specify a different shape for each clarity. ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price, shape = clarity)) mapping clarity to shape Here, while the mapping occurs correctly within ggplot2, we do get a warning message that discriminating more than six different shapes is difficult for the human eye. Thus, ggplot2 won’t allow more than six different shapes on a plot. This suggests that while you can do something, it’s not always the best to do that thing. Here, with more than six levels of clarity, it’s best to stick to mapping this variable to color as we did initially. To manually specify a shape for all the points on your plot, you would specify it outside of aes using one of the twenty-five different shape options available: options for points in ggplot2’s shape For example, to plot all of the points on the plot as filled diamonds (it is a dataset about diamonds after all…), you would specify shape ‘18’: ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price), shape = 18) specifying filled diamonds as shape for all points manually 3.0.5 Facets In addition to mapping variables to different aesthetics, you can also opt to use facets to help make sense of your data visually. Rather than plotting all the data on a single plot and visually altering the point size or color of a third variable in a scatterplot, you could break each level of that third variable out into a separate subplot. To do this, you would use faceting. Faceting is particularly helpful for looking at categorical variables. To use faceting, you would add an additional layer (+) to your code and use the facet_wrap() function. Within facet wrap, you specify the variable by which you want your subplots to be made: ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price)) + facet_wrap(~clarity, nrow = 2) Here, read the tilde as the word “by”. Specifically here, we want a scatterplot of the relationship between carat and price and we want it faceted (broken down) by (~) clarity. facet_wrap breaks plots down into subplots Now, we have eight different plots, one for each level of clarity, where we can see the relationship between diamond carats and price. You’ll note here we’ve opted to specify that we want 2 rows of subplots (nrow = 2). You can play around with the number of rows you want in your output to customize how your output plot appears. 3.0.6 Geoms Thus far in this lesson we’ve only looked at scatterplots, which means we’ve only called geom_point. However, there are many additional geoms that we could call to generate different plots. Simply, a geom is just a shape we use to represent the data. In the case of scatterplots, they don’t really use a geom since each actual point is plotted individually. Other plots, such as the boxplots, barplots, and histograms we described in previous lessons help to summarize or represent the data in a meaningful way, without plotting each individual point. The shapes used in these different types of plots to represent what’s going on in the data is that plot’s geom. To see exactly what we mean by geoms being “shapes that represent the data”, let’s keep using the diamonds dataset, but instead of looking at the relationship between two numeric variables in a scatterplot, let’s take a step back and take a look at a single numeric variable using a histogram. 3.0.6.1 Histograms: geom_histogram To review, histograms allow you to quickly visualize the range of values your variable takes and the shape of your data. (Are all the numbers clustered around center? Or, are they all at the extremes of the range? Somewhere in between? The answers to these questions describe the “shape” of the values of your variable.) For example, if we wanted to see what the distribution of carats was for these data, we could to the following. ggplot(data = diamonds) + geom_histogram(mapping = aes(carat)) histogram of carat shows range and shape The code follows what we’ve seen so far in this lesson; however, we’ve now called geom_histogram to specify that we want to plot a histogram rather than a scatterplot. Here, the rectangular boxes on the plot are geoms (shapes) that represent the number of diamonds that fall into each bin on the plot. Rather than plotting each individual point, histograms use rectangular boxes to summarize the data. This summarization helps us quickly understand what’s going on in our dataset. Specifically here, we can quickly see that most of the diamonds in the dataset are less than 1 carat. This is not necessarily something we could be sure of from the scatterplots generated previously in this lesson (since some points could have been plotted directly on top of one another). Thus, it’s often helpful to visualize your data in a number of ways when you first get a dataset to ensure that you understand the variables and relationships between variables in your dataset! 3.0.6.2 Barplots: geom_bar Barplots show the relationship between a set of numbers and a categorical variable. In the diamonds data set, we may be interested in knowing how many diamonds there are of each cut of diamonds. There are five categories for cut of diamond. If we make a barplot for this variable, we can see the number of diamonds in each category. ggplot(data = diamonds) + geom_bar(mapping = aes(cut)) Again, the changes to the code are minimal. We are now interested in plotting the categorical variable cut and state that we want a bar plot, by including geom_bar(). diamonds barplot Here, we again use rectangular shapes to represent the data, but we’re not showing the distribution of a single variable (as we were with geom_histogram). Rather, we’re using rectangles to show the count (number) of diamonds within each category within cut. Thus, we need a different geom: geom_bar! 3.0.6.3 Boxplots: geom_boxplot Boxplots provide a summary of a numerical variable across categories. For example, if you were interested to see how the price of a diamond (a numerical variable) changed across different diamond color categories (categorical variable), you may want to use a boxplot. To do so, you would specify that using geom_boxplot: ggplot(data = diamonds) + geom_boxplot(aes(x = color, y = price)) In the code, we see that again, we only have to change what variables we want to be included in the plot the type of plot (or geom) we want (here, geom_boxplot()) to get a basic boxplot. diamonds boxplot In the figure itself we see that the median price (the black horizontal bar in the middle of each box represents the median for each category) increases as the diamond color increases from the worst category (J) to the best (D). Now, if you wanted to change the color of this boxplot, it would just take a small addition to the code for the plot you just generated. ggplot(data = diamonds) + geom_boxplot(aes(x = color, y = price), fill = &quot;red&quot;) diamonds boxplot with red fill Here, by specifying the color “red” in the fill argument, you’re able to change the plot’s appearance. In the next lesson, we’ll go deeper into the many ways in which a plot can be customized within ggplot2! 3.0.6.4 Other plots While we’ve reviewed basic code to make a few common types of plots, there are a number of other plot types that can be made in ggplot2. These are listed in the online reference material for ggplot2 or can be accessed through RStudio directly. To do so, you would type ?geom_ into the Console in RStudio. A list of geoms will appear. You can hover your cursor over any one of these to get a short description. ?geom in Console Or, you can select a geom from this list and click enter. After selecting a geom, such as geom_abline and hitting ‘Enter,’ the help page for that geom will pop up in the ‘Help’ tab at bottom right. Here, you can find more detailed information about the selected geom. geom_abline help page 3.0.7 Summary In this lesson, we’ve walked through the basics of generating plots in ggplot2. You should be comfortable generating basic scatterplots, histograms, barplots, and boxplots after this lesson. You should also know how to interpret each of these plots. Finally, you should also know how to map variables within ggplot2 to specify what variables you want to plot, what colors the points should be mapped to, and how to specify the size/shape of those points. In the next lesson we’ll get into details about how to customize your plots further by adjusting font size, customizing labels and annotation, and incorporating different themes into your plots. 3.0.8 Additional Resources: R For Data Science by Hadley Wickham ggplot2 ggplot2 reference 3.0.9 Slides and Video Introduction to ggplot2 Slides "],["customization-in-ggplot2.html", "Chapter 4 Customization in ggplot2", " Chapter 4 Customization in ggplot2 In the previous lesson, we walked through the steps of generating a number of different graphs (using different geoms) in ggplot2. We discussed the basics of mapping variables to your graph to customize its appearance or aesthetic (using size, shape, and color within aes(). In this lesson, we’ll build on what we’ve previously learned to really get down to how to customize your plots so that they’re as clear as possible for communicating your results to others. The skills learned in this lesson will help take you from generating exploratory plots that help you better understand your data to explanatory plots – plots that help you communicate your results to others. We’ll cover how to customize the colors, labels, legends, and text used on your graph. Since we’re already familiar with it, we’ll again use the diamonds dataset that we’ve been using to learn about ggplot2. 4.0.1 Colors To get started, we’ll learn how to control color across plots in ggplot2. in the last lesson we discussed using color within aes() on a scatterplot to automatically color points by the clarity of the diamond when looking at the relationship between price and carat. color within aes() to color points However, what if we wanted to carry this concept over to a bar plot and look at how many diamonds we have of each clarity group? ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity)) diamonds broken down by clarity Well that’s a start since we see the breakdown, but all the bars are the same color. What if we adjusted color within aes()? ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, color = clarity)) color does add color but around the bars As expected, color added a legend for each level of clarity; however, it colored the lines around the bars on the plot, rather than the bars themselves. In order to color the bars themselves, you want to specify the more helpful argument fill: ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = clarity)) fill automatically colors the bars Great! We now have a plot with bars of different colors, which was our first goal! However, adding colors here, while maybe making the plot prettier doesn’t actually give us any more information. We can see the same pattern of which clarity is most frequent among the diamonds in our dataset that we could in the first plot we made. Color is particularly helpful here, however, if we wanted to map a different variable onto each bar. For example, what if we wanted to see the breakdown of diamond “cut” within each “clarity” bar? ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut)) mapping a different variable to fill provides new information Now we’re getting some new information! We can see that each level in clarity appears to have diamonds of all levels of cut. Color here has really helped us understand more about the data. But what if we were going to present these data? While there is no comparison between red and green (which is good!), there is a fair amount of yellow in this plot. Some projectors don’t handle projecting yellow well, and it will show up too light on the screen. To avoid this, let’s manually change the colors in this bar chart! To do so we’ll add an additional layer to the plot using scale_fill_manual. ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut)) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) manually setting colors using scale_fill_manual Here, we’ve specified five different colors within the values argument of scale_fill_manual(), one for each cut of diamond. The names of these colors can be specified using the names explained on the third page of the cheatsheet here. (Note: There are other ways to specify colors within R. Explore the details in that cheatsheet to better understand the various ways!) Additionally, it’s important to note that here we’ve used scale_fill_manual to adjust the color of what was mapped using fill = cut. If we had colored our chart using color within aes(), there is a different function called scale_color_manual. This makes good sense! You use scale_fill_manual() with fill and scale_color_manual() with color. Keep that in mind as you adjust colors in the future! Now that we have some sense of which clarity is most common in our diamonds dataset and were able to successfully specified the colors we wanted manually in order to make this plot useful for presentation, what if we wanted to compare the proportion of each cut across the different clarities? Currently that’s difficult because there is a different number within each clarity. In order to compare the proportion of each cut we have to use position adjustment. What we’ve just generated is a stacked bar chart. It’s a pretty good name for this type of chart as the bars fur cut are all stacked on top of one another. If you don’t want a stacked bar chart you could use one of the other position options: identity, fill, or dodge. Returning to our question about proportion of each cut within each clarity group, we’ll want to use position = \"fill\". Building off of what we’ve already done: ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut), position = &quot;fill&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) position = \"fill\" allows for comparison of proportion across groups Here, we’ve specified how we want to adjust the position of the bars in the plot. Each bar is now of equal height and we can compare each colored bar across the different clarities. As expected, we see that among the best clarity group (IF), we see more diamonds of the best cut (“Ideal”)! Briefly, we’ll take a quick detour to look at position = \"dodge\". This position adjustment places each object next to one another. This will not allow for easy comparison across groups, as we just saw with the last group but will allow values within each clarity group to be visualized. ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut), position = &quot;dodge&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) position = \"dodge\" helps compare values within each group Unlike in the first plot where we specified fill = cut, we can actually see the relationship between each cut within the lowest clarity group (I1). Before, when the values were stacked on top of one another, we were not able to visually see that there were more “Fair” and “Premium” cut diamonds in this group than the other cuts. Now, with position = \"dodge\", this information is visually apparent. Note: position = \"identity\" is not very useful for bars, as it places each object exactly where it falls within the graph. For bar charts, this will lead to overlapping bars, which is not visually helpful. However, for scatterplots (and other 2-Dimensional charts), this is the default and is exactly what you want. 4.0.2 Labels Text on plots is incredibly helpful. A good title tells viewers what they should be getting out of the plot. Axis labels are incredibly important to inform viewers of what’s being plotted. Annotations on plot help guide viewers to important points in the plot. We’ll discuss how to control all of these now! 4.0.2.1 Titles Now that we have an understanding of how to manually adjust color, let’s improve the clarity of our plots by including helpful labels on our plot by adding an additional labs() layer. We’ll return to the plot where we were comparing proportions of diamond cut across diamond clarity groups. You can include a title, subtitle, and/or caption within the labs() function. Each argument, as per usual, will be specified by a comma. ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut), position = &quot;fill&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) + labs( title = &quot;Clearer diamonds tend to be of higher quality cut&quot;, subtitle = &quot;The majority of IF diamonds are an \\&quot;Ideal\\&quot; cut&quot;) labs() adds helpful tittles, subtitles, and captions 4.0.2.2 Axis labels You may have noticed that our y-axis label says “count”, but it’s not actually a count anymore. In reality, it’s a proportion. Having appropriately labeled axes is so important. Otherwise, viewers won’t know what’s being plotted. So, we should really fix that now using the ylab() function. Note: we won’t be changing the x-axis label, but if you were interested in doing so, you would use xlab(\"label\"). ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut), position = &quot;fill&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) + labs( title = &quot;Clearer diamonds tend to be of higher quality cut&quot;, subtitle = &quot;The majority of IF diamonds are an \\&quot;Ideal\\&quot; cut&quot;) + ylab(&quot;proportion&quot;) Accurate axis labels are incredibly important 4.0.3 Themes To change the overall aesthetic of your graph, there are 8 themes built into ggplot2 that can be added as an additional layer in your graph: themes For example, if we wanted remove the gridlines and grey background from the chart, we would use theme_classic(). Building on what we’ve already generated: ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut), position = &quot;fill&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) + labs( title = &quot;Clearer diamonds tend to be of higher quality cut&quot;, subtitle = &quot;The majority of IF diamonds are an \\&quot;Ideal\\&quot; cut&quot;) + ylab(&quot;proportion&quot;) + theme_classic() theme_classic changes aesthetic of our plot We now have a pretty good looking plot! However, a few additional changes would make this plot even better for communication. Note: Additional themes are available from the ggthemes package. Users can also generate their own themes. 4.0.4 Theme In addition to using available themes, we can also adjust parts of the theme of our graph using an additional theme() layer. There are a lot of options within theme. To see them all, look at the help documentation within RStudio Cloud using: ?theme. We’ll simply go over the syntax for using a few of them here to get you comfortable with adjusting your theme. Later on, you can play around with all the options on your own to become an expert! 4.0.4.1 Altering text size For example, if we want to increase text size to make it more easily viewable when presenting this graph, we would do that within theme. Notice here that we’re increasing the text size of the title, axis.text, axis.title, and legend.text all within theme()! The syntax here is important. Within each of the elements of the theme you want to alter, you have to specify what it is you want to change. Here, for all three, we want to later text, so we specify element_text(). Within that, we specify that it’s size that we want to adjust. ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut), position = &quot;fill&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) + labs( title = &quot;Clearer diamonds tend to be of higher quality cut&quot;, subtitle = &quot;The majority of IF diamonds are an \\&quot;Ideal\\&quot; cut&quot;) + ylab(&quot;proportion&quot;) + theme_classic() + theme( title = element_text(size = 18), axis.text = element_text(size =14), axis.title = element_text(size = 16), legend.text = element_text(size = 14) ) theme() allows us to adjust font size 4.0.4.2 Additional text alterations Changing the size of text on your plot is not the only thing you can control within theme(). You can make text bold* and change its color within theme(). Note here that multiple changes can be made to a single element. We can change size and make the text bold**. All we do is separate each argument with a comma, per usual. ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut), position = &quot;fill&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) + labs( title = &quot;Clearer diamonds tend to be of higher quality cut&quot;, subtitle = &quot;The majority of IF diamonds are an \\&quot;Ideal\\&quot; cut&quot;) + ylab(&quot;proportion&quot;) + theme_classic() + theme( title = element_text(size = 18), axis.text = element_text(size = 14), axis.title = element_text(size = 16, face = &quot;bold&quot;), legend.text = element_text(size = 14), plot.subtitle = element_text(color = &quot;gray30&quot;) ) theme() allows us to tweak many parts of our plot Any alterations to plot spacing/background, title, axis, and legend will all be made within theme() 4.0.5 Legends At this point, all the text on the plot is pretty visible! However, there’s one thing that’s still not quite clear to viewers. In daily life, people refer to the “cut” of a diamond by terms like “round cut” or “princess cut” to describe the shape of the diamond. That’s not what we’re talking about here when we’re discussing “cut”. In these data, “cut” refers to the quality of the diamond, not the shape. Let’s be sure that’s clear as well! We can change that using an additional layer and guides()! ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity, fill = cut), position = &quot;fill&quot;) + scale_fill_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;darkgreen&quot;, &quot;dodgerblue&quot;, &quot;purple4&quot;)) + labs( title = &quot;Clearer diamonds tend to be of higher quality cut&quot;, subtitle = &quot;The majority of IF diamonds are an \\&quot;Ideal\\&quot; cut&quot;) + ylab(&quot;proportion&quot;) + theme_classic() + theme( title = element_text(size = 18), axis.text = element_text(size = 14), axis.title = element_text(size = 16, face = &quot;bold&quot;), legend.text = element_text(size = 14), plot.subtitle = element_text(color = &quot;gray30&quot;) ) + guides(fill = guide_legend(&quot;cut quality&quot;)) guide() allows us to change the legend title At this point, we have an informative title, clear colors, a well-labeled legend, and text that is large enough throughout the graph. This is certainly a graph that could be used in a presentation. We’ve taken it from a graph that is useful to just ourselves (exploratory) and made it into a plot that can communicate our findings well to others (explanatory)! We have touched on a number of alterations you can make by adding additional layers to a ggplot. In the rest of this lesson we’ll touch on a few more changes you can make within ggplot2 using a slightly different graph. 4.0.6 Scales There may be times when you want a different number of values to be displayed on an axis. The scale of your plot for continuous variables (i.e. numeric variables) can be controlled using scale_x_continuous or scale_y_continuous. Here, we want to increase the number of labels displayed on the y-axis, so we’ll use scale_y_continuous: ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity)) + scale_y_continuous(breaks = seq(0, 17000, by = 1000)) Continuous cales can be altered However, for discrete variables (aka factors or categorical variables), where there is a limited number of levels, you would use scale_x_discrete or scale_y_discrete: ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity)) + scale_x_discrete(limit = c(&quot;SI2&quot;, &quot;SI1&quot;, &quot;I1&quot;)) + scale_y_continuous(breaks = seq(0, 17000, by = 1000)) Discrete scales can be altered 4.0.7 Coordinate Adjustment There are times when you’ll want to flip your axis. This can be accomplished using coord_flip(). Adding an additional layer to the plot we just generated switches our x- and y-axes, allowing for horizontal bar charts, rather than the default vertical bar charts: ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity)) + scale_y_continuous(breaks = seq(0, 17000, by = 1000)) + scale_x_discrete(limit = c(&quot;SI2&quot;, &quot;SI1&quot;, &quot;I1&quot;)) + coord_flip() + labs( title = &quot;Clearer diamonds tend to be of higher quality cut&quot;, subtitle = &quot;The majority of IF diamonds are an \\&quot;Ideal\\&quot; cut&quot;) + ylab(&quot;proportion&quot;) + theme_classic() + theme( title = element_text(size = 18), axis.text = element_text(size = 14), axis.title = element_text(size = 16, face = &quot;bold&quot;), legend.text = element_text(size = 14), plot.subtitle = element_text(color = &quot;gray30&quot;) ) + guides(fill = guide_legend(&quot;cut quality&quot;)) Axes can be flipped using coord_flip It’s important to remember that all the additional alterations we already discussed can still be applied to this graph! ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity)) + scale_y_continuous(breaks = seq(0, 17000, by = 1000)) + scale_x_discrete(limit = c(&quot;SI2&quot;, &quot;SI1&quot;, &quot;I1&quot;)) + coord_flip() + labs( title = &quot;Number of diamonds by diamond clarity&quot;, subtitle = &quot;Subset of all diamonds, looking three levels of clarity&quot;) + theme_classic() + theme( title = element_text(size = 18), axis.text = element_text(size = 14), axis.title = element_text(size = 16, face = &quot;bold&quot;), legend.text = element_text(size = 14), plot.subtitle = element_text(color = &quot;gray30&quot;) ) Additional layers will help customize this plot 4.0.8 Annotation Finally, there will be times when you’ll want to add text to a plot or to annotate points on your plot. We’ll discuss briefly how to accomplish that here! To add text to your plot, we can use the function annotate. This requires us to specify that we want to annotate here with a “text” geom (rather than say a shape, like a rectangle - “rect”). Additionally, we have to specify what we’d like that text to say (label), where on the plot we’d like that text to show up (using x and y for coordinates), how we’d like the text aligned (using hjust for horizontal alignment where the options are “left”, “center”, or “right” and vjust for vertical alignment where the arguments are “top”, “center” or “bottom”), and how big we’d like that text to be (size): ggplot(data = diamonds) + geom_bar(mapping = aes(x = clarity)) + scale_y_continuous(breaks = seq(0, 17000, by = 1000)) + scale_x_discrete(limit = c(&quot;SI2&quot;, &quot;SI1&quot;, &quot;I1&quot;)) + coord_flip() + labs( title = &quot;Number of diamonds by diamond clarity&quot;, subtitle = &quot;Subset of all diamonds, looking three levels of clarity&quot;) + theme_classic() + theme( title = element_text(size = 18), axis.text = element_text(size = 14), axis.title = element_text(size = 16, face = &quot;bold&quot;), legend.text = element_text(size = 14), plot.subtitle = element_text(color = &quot;gray30&quot;) ) + annotate(&quot;text&quot;, label = &quot;SI1 diamonds are among \\n the most frequent clarity diamond&quot;, y = 12800, x = 2.9, vjust = &quot;top&quot;, hjust = &quot;right&quot;, size = 6) annotate helps add text to our plot Note: we could have accomplished this by adding an additional geom: geom_text. However, this requires creating a new data frame, as explained here. This can also be used to label the points on your plot. Keep this reference in mind in case you have to do that in the future. 4.0.9 Summary In this lesson we’ve covered how to manually change the colors of your plot in R, how to use built-in ggplot2 themes, how to tailor your plot to look exactly how you want it to look within theme(), how to customize legends, how to scale axes, how to flip coordinates, and how to annotate your plots. What’s important to remember is that ggplot2 is flexible and benefits from its layered nature. Additionally, it’s important to remember that the last lesson and this lesson have just touched the surface of what’s capable in ggplot2. You’ll certainly run into things when graphing that were not covered in this lesson, and that’s great! That means you’re beginning to master ggplot2. Use what you’ve learned here and additional online available resources to generate any plot you can think of! 4.0.10 Additional References Color Cheatsheet ggthemes package - GitHub repo R4DS: Chapter 3 R4DS: Chapter 18 4.0.11 Slides and Video Customization in ggplot2 Slides "],["saving-plots.html", "Chapter 5 Saving Plots", " Chapter 5 Saving Plots While you’ll frequently be generating R Markdown documents where figures are generated directly as the file is knit, it is nonetheless important to know how to save an image directly. This is helpful when you have to add plots into slide presentations (using Google Slides, for example) or to send a quick update to your team. In this lesson, we’ll discuss how to save plots you’ve generated in R within RStudio Cloud as images that you can share with others as you need. 5.0.1 Image Types There are a number of different image file formats that can be generated from R. We will only discuss four of them here, but we’ll list the other possible file formats in each of the following sections, so that you know what types of files can be generated from R. In R, frequently, individuals tend to generate one of the following four file formats. Brief characteristics of each file format are summarized here. These are worth considering when deciding what type of image you want to generate: JPEG - a popular file format that will take up less space on your computer due to how its compressed. Figures that are saved multiple times, however, will lose quality each time they’re saved. These files have a white background by default. PNG - a high-quality bitmap image file format that preserves its integrity over time. Due to this, these images will take up more storage space. The background of these files is transparent. There will be no white border around these images. If magnified, pixels may be visible. TIFF - a bitmap file format. TIFF files are not meant to compress but are meant to preserve quality over time. TIFF images can be edited using photo editors, such as Photoshop. Use this file format if you intend to edit this image later. If magnified, pixels may be visible. PDF - a vector file format. This is most helpful if you want to plot multiple images to a single file or when you want to print your images, as they can be scaled to any size without suffering from pixelation. file format summary 5.0.2 Saving Plots: ggsave() We’ve discussed how to generate plots using ggplot2, and here we will discuss how to save them using the convenient function ggsave(). By specifying the plot you want to save, the filename you want the file output to have and the path, or destination where you want this plot to be saved, you can quickly and easily save any plot generated in ggplot2. To save a different file format, you simply change the file extension in the filename argument. ggsave() will output plots in any of the following file formats: “eps”, “ps”, “tex” (pictex), “pdf”, “jpeg”, “tiff”, “png”, “bmp”, “svg” or “wmf” (on Windows only). For example, here we see how to save a plot in the “figures/exploratory_figures” directory. The code demonstrates how to save it both as a PNG and JPEG image. ## generate plot myplot &lt;- ggplot(mtcars, aes(wt, mpg)) + geom_point() ## save plot as PNG ggsave(plot = myplot, filename = &quot;myplot.png&quot;, path = &quot;figures/exploratory_figures&quot;) ## save plot as JPEG ggsave(plot = myplot, filename = &quot;myplot.jpeg&quot;, path = &quot;figures/exploratory_figures&quot;) There are additional arguments within ggsave. In particular, you will often want to adjust the size of your images. You can control the size of your image using the height and width arguments. Additionally, ggsave() allows you to specify the units of those height and width arguments as either inches (“in”), centimeters (“cm”), or millimeters (“mm”). For example, to increase the size of and overwrite the PNG image created above, you could use the following: ## save plot as larger PNG ggsave(plot = myplot, filename = &quot;myplot.png&quot;, path = &quot;figures/exploratory_figures&quot;, height = 9, width = 9, unit = c(&quot;in&quot;)) 5.0.3 Alternative Approach As ggsave() is an incredibly simple function,, we recommend that you use that to generate images. However, there may be times where you run into trouble saving an image or see someone else has saved an image in a different way. In addition to ggsave(), there are a number of graphics devices that you can use to save plots as images. We recommend you use ggsave(); however we want you to additionally be aware of an alternative way to generate image files. To utilize the graphics devices outside of ggsave(), you first call the graphics device with the appropriate function: png(), jpeg(), pdf(), or tiff(). Within this function call, you’ll specify the path to and name of the file you’d like to save. You then print the image object. Once done, you always have to type dev.off() to finalize the image file generation. For example, to generate a png, you would use the following: png(&quot;figures/exploratory_figures/myplot.png&quot;) print(myplot) dev.off() To generate a JPEG, you would use this very similar syntax, but ensure that you change the initial function call to jpeg and the file extension to “.jpeg”: jpeg(&quot;figures/exploratory_figures/myplot.jpeg&quot;) print(myplot) dev.off() Similar to above, the height, width can again be specified, as above. For jpeg, bmp, and tiff files, units can also be specified (as either pixels (“px”), inches (“in”), centimeters (“cm”), or millimeters (“mm”). The default is pixels. When generating PDFs using pdf() there are additional arguments that can be viewed using ?pdf; however, there is no units argument to be specified. 5.0.4 Additional Resources R Cookbook - Further reading on file formats in R 5.0.5 Slides and Video Saving Plots Slides "],["from-exploratory-to-explanatory.html", "Chapter 6 From Exploratory To Explanatory", " Chapter 6 From Exploratory To Explanatory In the lessons in this course up to this point, we have covered what to consider when making a plot, the basics of using ggplot2 to generate plots in R, how to customize ggplot2 plots, and how to save figures. In this lesson we’re going to put all of those skills together and walk through an example of how to take a plot from exploratory (its roughest form) to explanatory (polished and ready to be presented). 6.0.1 Apple Product Sales Data To discuss going from exploratory plots, such as the four plots made last lesson reviewing common geoms used in ggplot2, to explanatory plots, such as the iPhone plot we recreated from Lisa Charlotte Rost’s blog post, we’ll leverage the fact that ggplot2 is incredibly flexible and allows for layering. This means that if you can think of a change you want to make to your plot, there is almost always a way to make it happen in ggplot2. To discuss the types of changes you can make to plots, we’ll return to the iPhone sales plot we looked at in an earlier lesson in this course where we discussed considerations that should be made when making good plots and use that as an example. We’ll walk through the code used to make that plot and highlight the types of changes you can make to the the overall appearance of a plot step-by-step. Final reproduction of blog post plot Before we do that, let’s take a glance at the data used to make this plot. data for iPhone plot The variables used to reproduce the blog post graph are: yrq - a variable for the year and quarter from which the sales of the Apple product was recorded variable - which Apple Product we’re talking about (iPhone, iPad, or iPod) value - the sales for that Apple product in that year and quarter in millions of US dollars. NA means no data were available for that product in that year-quarter. 6.0.2 Exploratory Plot While there is a lot of code that led to this final product of this plot, you’ll note that it still starts with the same basic framework we already discussed. There is a ggplot() call and then the geom is defined. Here, as we wanted a line for each Apple product, so we specify the geom geom_line(). This isn’t a geom we have discussed explicitly yet, but it connects the points on a plot with a single line. It’s helpful for plotting data over time, which is exactly what we’re doing here! In addition to specifying the x and y arguments within aes(), we are also specifying the group and color arguments, both of which we have discussed previously. Here, group lets ggplot2 to map the variable variable to three different lines (one for each Apple product) and color specifies that we want to map the variable variable to three different colors. plot code highlighting first two lines In fact, if we were to just run these two lines of code, we would have a reasonable exploratory plot. ggplot(data = df2, aes(x = yrq, y = value, group = variable, color = variable)) + geom_line() Exploratory plot While this plot is not nearly as clear nor as pretty as the final plot, you can better understand the data at this point, which is precisely the goal of an exploratory plot. You may notice that in this code aes is including within the ggplot() function rather than within geom_line(). We could have put aes within geom_line() as we’ve done previously; however, when aes() is included in ggplot(), its arguments are used throughout each subsequent function that is called. As we aren’t going to be changing the x, y, group, or color variable in subsequent function calls, there is no harm in including these arguments within ggplot() rather than geom_line. Feel free to play around with aes to see if anything changes if you move it to geom_line()! 6.0.3 Increasing Line Thickness The lines on this plot are a little too thin to be seen easily and certainly not as thick as the lines on the original plot. So, let’s use the size argument within geom_line to make these lines thicker and more visible. ggplot(data = df2, aes(x = yrq, y = value, group = variable, color = variable)) + geom_line(size = 1.5) size increases line thickness 6.0.4 Adding a Title Before we go any further, we’ll want to consider including a great title. As discussed at the beginning of this lesson, it’s important to add a title that tells viewers what conclusions that should draw from the plot. ggtitle() allows the addition of both a title and a subtitle to any plot made with ggplot2. ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) ggtitle adds title to plot Here, we’re using the same title and subtitle as was used in the plot originally. 6.0.5 Changing Line Colors Here, since we’ve specified a variable to color in our aes() originally, we’re able to manually control what the colors of this color variable are. We do that within the function scale_colour_manual() by specifying the three colors for our three lines using the values argument. ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) scale_colour_manual allows for manual control of the line colors 6.0.6 Specifying a Theme Before we go any further, let’s just remove that gray background. To do so, we’ll use the very helpful black and white theme: theme_bw() ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() theme_bw() gets us closer to the aesthetic we’re looking for 6.0.7 Customizing the Theme After getting closer to the look we want, we can modify the theme specifically using theme(). To get us started we’ll first remove the vertical gridlines. Note that within theme, when you want to remove a theme element you specify that by setting the theme element to element_blank(). ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() ) removing vertical grid lines We can then remove the axis labels yrq and value from the plot. The necessary information about what is plotted on each axis is included in the subtitle already on this plot ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank() ) removing axis labels Now, let’s increase the size of those axis labels and the plot title, so that they’re clear to anyone looking at this plot! ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text = element_text(size=15), plot.title = element_text(size = 22), plot.subtitle = element_text(size = 15) ) increase font size across plot Now, let’s just make a few more tweaks. Let’s first remove the legend because we’re going to directly label the lines in a few steps and let’s remove the unnecessary border around the plot. ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text = element_text(size=15), plot.title = element_text(size = 22), plot.subtitle = element_text(size = 15), legend.position =&quot;none&quot;, panel.border = element_blank() ) Removing the legend and border around the plot Now that the border has been removed, we’re kind of squished up right against the edge of the plotting area. We can increase the area around the plot by specifying plot.margin. The default for this argument is plot.margin = unit(c(1, 1, 0.5, 0.5), \"lines\") where the four numbers correspond to the top, right, bottom, and left of the plot. Here, by increasing the value from 0.5 to 1 we’re increasing the space in the margin area beneath and to the left of the plot a bit. ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text = element_text(size=15), plot.title = element_text(size = 22), plot.subtitle = element_text(size = 15), legend.position =&quot;none&quot;, panel.border = element_blank(), plot.margin = unit(c(1,1,1,1), &quot;lines&quot;), ) Adjusting plot margin 6.0.8 Customizing Axis Labels Now that we’ve got the theme pretty close to what we want and have increased the size of the font on the axes, it’s clear that they’re not quite displaying enough information. We can specify how and what values are displayed on the x and y axis so that each year is displayed along the x-axis and multiples of ten along the y-axis. ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text = element_text(size=15), plot.title = element_text(size = 22), plot.subtitle = element_text(size = 15), legend.position =&quot;none&quot;, panel.border = element_blank(), plot.margin = unit(c(1,1,1,1), &quot;lines&quot;), ) + scale_x_yearqtr(limits = c(2004, 2015), format = &quot;%Y&quot;, breaks=c(2004:2015), expand = c(0.1, 0.01)) + scale_y_continuous(breaks = c(0,10,20,30,40,50,60,70,80)) controlling axis labels 6.0.9 Adding direct labels There isn’t direct functionality to directly label lines in ggplot2, but someone has written a package called directlabels to do just that for plots generated in ggplot2. Here we add an additional geom, geom_dl to label our lines directly. ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text = element_text(size=15), plot.title = element_text(size = 22), plot.subtitle = element_text(size = 15), legend.position =&quot;none&quot;, panel.border = element_blank(), plot.margin = unit(c(1,1,1,1), &quot;lines&quot;), ) + scale_x_yearqtr(limits = c(2004, 2015), format = &quot;%Y&quot;, breaks=c(2004:2015), expand = c(0.1, 0.01)) + scale_y_continuous(breaks = c(0,10,20,30,40,50,60,70,80)) + geom_dl(aes(label = variable), method = list(c(&quot;last.points&quot;), aes(colour = &quot;black&quot;), cex = 1.3) ) geom_dl directly labels our three lines 6.0.9.1 Adding Annotations The plot is really close to complete at this point. But, to really make it as explanatory as possible, we want to annotate the plot to draw viewers attention to a particular point on the plot. To do so in ggplot2, we’ll use annotate(). Here, we’ll use annotate() to both to add the grey rectangle and to add the text to the plot explaining that in 2010 was the first year when more iPhones were sold than iPods. First, we specify we want to generate a “rect” using annotate and include the limits of that rectangle. ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text = element_text(size=15), plot.title = element_text(size = 22), plot.subtitle = element_text(size = 15), legend.position =&quot;none&quot;, panel.border = element_blank(), plot.margin = unit(c(1,1,1,1), &quot;lines&quot;), ) + scale_x_yearqtr(limits = c(2004, 2015), format = &quot;%Y&quot;, breaks=c(2004:2015), expand = c(0.1, 0.01)) + scale_y_continuous(breaks = c(0,10,20,30,40,50,60,70,80)) + geom_dl(aes(label = variable), method = list(c(&quot;last.points&quot;), aes(colour = &quot;black&quot;), cex = 1.3) ) + annotate(&quot;rect&quot;, xmin = 2010, xmax = 2011, ymin = 0, ymax = Inf, fill = &quot;grey&quot;, alpha = 0.2) adding the rectangle to draw attention Within annotate, we to specify the geom you want to add to the plot (here we add “rect” and “text”) and the x- and y-coordinates on the graph where you want the annotation to appear. Additionally, you also have the ability to control a number of parameters, including: alpha - the transparency of shapes on the plot size - the size of the text hjust - the horizontal alignment of text (vjust controls vertical alignment) Finally, we can again use annotate() to add text directly to the plot to explain what that gray box is highlighting. Here, we specify that this annotation is “text” (rather than “rect”) and include information about where we want that annotation to appear on the plot (x and y), what we want it to say (label), how we want it to be aligned (hjust), and how big it should be (size). ggplot(data = df2, aes(x = yrq,y = value, group = variable, color = variable)) + geom_line(size = 1.5) + ggtitle(&quot;iPhone more successful than all other Apple products&quot;, subtitle=&quot;Worldwide sales of selected Apple products in million, by fiscal quarter, 2000 to 2014&quot;) + scale_colour_manual(values = c(&quot;red3&quot;,&quot;grey&quot;,&quot;grey&quot;)) + theme_bw() + theme( panel.grid.major.x = element_blank() , panel.grid.minor.x = element_blank() , axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text = element_text(size=15), plot.title = element_text(size = 22), plot.subtitle = element_text(size = 15), legend.position =&quot;none&quot;, panel.border = element_blank(), plot.margin = unit(c(1,1,1,1), &quot;lines&quot;), ) + scale_x_yearqtr(limits = c(2004, 2015), format = &quot;%Y&quot;, breaks=c(2004:2015), expand = c(0.1, 0.01)) + scale_y_continuous(breaks = c(0,10,20,30,40,50,60,70,80)) + geom_dl(aes(label = variable), method = list(c(&quot;last.points&quot;), aes(colour = &quot;black&quot;), cex = 1.3) ) + annotate(&quot;rect&quot;, xmin = 2010, xmax = 2011, ymin = 0, ymax = Inf, fill = &quot;grey&quot;, alpha = 0.2) + annotate(&quot;text&quot;, x = 2010.5, y = 40, label = &quot;After Apple announced \\n the iPhone 4 in 2010, \\n more iPhones were sold \\n than iPods for the first time.&quot;, hjust = 1, size=6) adding text to plot 6.0.10 Explanatory Plot With all of these changes, you now have a beautiful plot that accomplishes everything an explanatory plot should. It conveys information clearly to the viewer, is well-labeled, and draws the attention of the viewer to the important parts of the graph. Explanatory Plot We point these out now not so you master each of these alterations, but rather so that you have some idea of what it takes to take an exploratory plot that you generally make very quickly for your own purposes and turn it into an explanatory plot that clearly communicates your results to someone else. As we walked through this example, you saw that it can take a lot of code to generate a polished graph. As you practice making plots in R, know that it’s typical to struggle to figure out how to make the plot look exactly the way you want. Google will help here and so will people on stack overflow. Googling your specific question and looking for solutions in R that other people have already come up with is a great place to start whenever you’re stuck trying to figure out something on a plot. Also, really great explanatory plots take time. It’s ok to spend a lot of time making a single important plot that effectively communicates your point. It can take a lot of code 6.0.11 Slides and Video From Exploratory To Explanatory Slides "],["data-tables.html", "Chapter 7 Data Tables", " Chapter 7 Data Tables So far, we’ve spent a fair amount of time discussing how to make great exploratory and explanatory plots. However, plots are not the only ways to display data. Often, a table is a perfect approach to summarizing and displaying your data. In this lesson, we’ll discuss when to consider making a table instead of a plot, what to consider when making your table, and how to make tables in R and RMarkdown. 7.0.1 What are Data Tables? Data tables are used to display data in a tabular format. They display the information in rows and columns. Good data tables do this in a meaningful and concise way. Similar to plots, tables can be exploratory (help you to better understand the data) or explanatory (beautifully and clearly display information in a table to others). Exploratory vs. explanatory tables In this lesson we will focus on characteristics of good plots and discuss how to take tables from exploratory to explanatory. 7.0.2 When to Make a Table Just as for deciding what type of plot to make given the data you want to display, it’s important to consider what you’re trying to convey when making a table. Tables are effective when you want to display summary information about a dataset or when you want to display top results from an analysis. 7.0.2.1 Summarize dataset information When you have an entire dataset, it’s often nice to have a table that summarizes important pieces of information. For example if you had a dataset with information on 32 different cars, you may be interested in the difference between cars in that dataset that have automatic vs. manual transmissions. Rather than go through and try to count them in this dataset, a table can do a nice job quickly summarizing and displaying this information for you. For example, you could display summarized information across a number of variables, such as how many of each type of car there are in your dataset (N), how fuel efficient the cars in each group are on average (mpg), the average weight of the cars in each group (weight), their average horsepower in each group (horsepower). This information can be easily displayed in a table. A table is better than a plot here because you’re trying to summarize information across a few different variables. A single plot that attempted to include all of this information would be less clear than this table. Similarly, four separate plots – one for each variable – would take up much more space. Thus, a table is the right approach here to display these data. Sample summary tables 7.0.2.2 Summarize top results Tables are also helpful when you want to display information about the top results from an analysis (i.e. the top 10 best-selling books, the business that had the highest sales last year, etc.). For example, if you had information about 162,049 different flights that departed the Pacific Northwest in 2014 and wanted to know which destinations had the longest average delay for flights out of the Pacific Northwest, you could use a data table to display these results. At a glance from this table we can clearly see which airports had the longest delay in arrival time without . Top results table 7.0.3 What to Consider When Making A Table When making a table, it’s important to keep the ordering and spacing of your table in mind. It’s important to make sure everything is labeled appropriately and values within the table are displayed sensibly. More specifically, we’ll discuss a number of considerations to make when designing tables. 7.0.3.1 What to put in columns and what to put in rows The human eye is much better at comparing values up and down rather than from left to right. Consider what comparisons you want viewers to be able to make easily when looking at the table. Then, put those in a column, rather than in a row. Results vertically are better than comparing horizontally 7.0.3.2 The order of rows Consider the data you’re putting in the table. If you’re displaying data over time, make sure the rows are in chronological order. If you’re displaying data about individuals, it’s likely best to order alphabetically by last name. Make sure that the order of rows helps viewers understand the table most quickly. For example, if you are displaying a table about longest delay in flight time arrival, it’s likely best to order the table from longest delay in the first row to shorter delays at the bottom of the table. Order rows logically 7.0.3.3 The order of columns Put the most informative and important columns at the left and the less important columns at the right to assist viewers who read from left to right. (In languages where reading occurs from right to left, the ordering of columns should be reversed.) Here, if we want viewers to understand which airports had the longest delays, it makes the most logical sense to start with the airport name at the left, rather than the mean arrival delay time, giving viewers some context about what they’re looking at before getting to the actual numbers. Order columns with most important information at left 7.0.3.4 The number of rows and columns Viewers should be able to figure out what the table is saying at a quick glance. If there are too many rows or too many columns, your data should most likely be a plot, not a table. For example, if you are displaying information about arrests in each of the 50 US states, it may be better to consider plots, as it’s difficult to draw any conclusions about these data across 50 different rows. However, when we are only comparing across 5 rows, as in the case of our top results from the flights analysis, we can easily make comparisons across these five airports whose data are included in the table. Limit the number of rows and columns 7.0.3.5 Labels Labels on your columns and rows should be informative and clear. If talking about the price of diamonds, a bad column label would be “P” and a better column label would be “price.” An even better column label would be “price (USD).” This label is preferred because it provides viewers with the unit for the values in the table, conveying that these prices are all in US dollars. Viewers should be able to easily determine what information the table is displaying. Below, the labels on the table at right are informative, whereas a viewer may not easily be able to determine what the column labels on the left (AN, AC, and MAD) mean. Labels should be informative and concise 7.0.3.6 Significant digits Including a lot of decimal places in a table is not helpful to viewers. Often, two significant digits is enough. You’ll want to always double check the values in your table to make sure they are displayed appropriately before finalizing a table. Consider whether the appropriate number of digits for values in your table has been used 7.0.3.7 A good title or caption Just like with good plots, good tables should have a title or caption that is clear and concise. It should tell viewers what they should determine from the data in the table. Including a good title or caption is critical 7.0.3.8 The source of the data Like with explanatory graphs, it’s important to include the source of the data used in your table at the bottom of the table when finalizing a table. Always include the source of the data in your table With an idea of how to make a great explanatory table, you’re ready to start practicing making your own in R. 7.0.4 Additional resources Intro to table design Data Tables in R slideshow 7.0.5 Slides and Video Data Tables Slides "],["tables-in-r.html", "Chapter 8 Tables in R", " Chapter 8 Tables in R Now that we have a good understanding of what to consider when making tables, we can to practice making good tables in R. To do this, we’ll return to the diamonds data set. As a reminder, this dataset contains prices and other information about ~54,000 different diamonds. If we want to provide viewers with a summary of these data, we may want to provide information about diamonds broken down by the quality of the diamond’s cut. To get the data we’re interested in, we’ll use the diamonds dataset and the dplyr R package, which we discussed in a lesson in an earlier course. 8.0.1 Getting the data in order To start figuring out how the quality of the cut of the diamond affects the price of that diamond, we first have to first get the data in order. To do that, we’ll use the dplyr package that you learned about in an earlier course in this series. This allows us to group the data by the quality of the cut (cut) before summarizing the data to determine the number of diamonds in each category (N), the minimum price of the diamonds in this category (min), the average price (avg), and the highest price in the category (max). To get these data in order, you could use the following code. This code groups the data by cut (quality of the diamond) and then calculates the number of diamonds in each group (N), the minimum price across each group (min), the average price of diamonds across each group (avg), and the maximum price within each group (max): library(dplyr) df &lt;- diamonds %&gt;% group_by(cut) %&gt;% dplyr::summarize( N = n(), min = min(price), avg = mean(price), max = max(price) ) 8.0.2 An exploratory table df By getting the data summarized into a single object in R (df), we’re on our way to making an informative table. However, this is clearly just an exploratory table. The output in R from this code follows some of the good table rules above, but not all of them. At a glance, it will help you to understand the data, but it’s not the finished table you would want to send to your boss. Exploratory diamonds table From this output, you, the creator of the table, would be able to see that there are a number of good qualities: there is a reasonable number of rows and columns - There are 5 rows and 5 columns. A viewer can quickly look at this table and determine what’s going on. the first column cut is organized logically - The lowest quality diamond category is first and then they are ordered vertically until the highest quality cut (`ideal)) Comparisons are made top to bottom - To compare between the groups, your eye only has to travel up and down, rather than from left to right. There are also things that need to be improved on this table: column headers could be even more clear there’s no caption/title It could be more aesthetically pleasing 8.0.3 Improving the table output By-default, R outputs tables in the Console using a monospaced font. However, this limits our ability to format the appearance of the table. To fix the remaining few problems with the table’s format, we’ll use the kable() function from the R package knitr and the additional formatting capabilities of the R packages kableExtra. The first step to a prettier table just involves using the kable() function from the knitr package, which improves the readability of this table kable(df) kable basic output However, there are still a few issues we want to improve upon: column names could be more informative too many digits in the avg column Caption/title is missing Source of data not included. To begin addressing these issues, we can use the add_header_above function from kableExtra() to specify that the min, avg, and max columns refer to price in US dollars (USD). Additionally, kable() takes a digits argument to specify how many significant digits to display. This takes care of the display of too many digits in the avg column. Finally, we can also style the table so that every other row is shaded, helping our eye to keep each row’s information separate from the other rows using kable_styling() from kableExtra. These few changes really improve the readability of the table. If you copy this code into your R console, the formatted table will show up in the Viewer tab at the bottom right-hand side of your RStudio console and the HTML code used to generate that table will appear in your console. library(knitr) library(kableExtra) kable(df, digits=0, &quot;html&quot;) %&gt;% kable_styling(&quot;striped&quot;, &quot;bordered&quot;) %&gt;% add_header_above(c(&quot; &quot; = 2, &quot;price (USD)&quot; = 3)) Viewer tab with formatted table 8.0.4 Annotating your table We mentioned earlier that captions and sourcing your data are incredibly important. The kable package allows for a caption argument. Below, an informative caption has been included. Additionally, kableExtra has a footnote() function. This allows you to include the source of your data at the bottom of the table. With these final additions, you have a table that clearly displays the data and could be confidently shared with your boss. kable(df, digits=0, &quot;html&quot;, caption=&quot;Table 1: Diamonds Price by Quality of Cut. Most Diamonds are of the highest quality cut and the most expensive diamonds are of the highest quality&quot;) %&gt;% kable_styling(&quot;striped&quot;, &quot;bordered&quot;) %&gt;% add_header_above(c(&quot; &quot; = 2, &quot;price (USD)&quot; = 3)) %&gt;% footnote(general=&quot;Diamonds dataset from ggplot2&quot;, general_title=&quot;Source:&quot;,footnote_as_chunk = T) Viewer tab with annotated and formatted table 8.0.5 Tables in RMarkdown So far, this has all been done within RStudio. However, in a lesson in an earlier course in this series, we discussed the importance of making reports in RMarkdown. The previous lesson focused on how to format RMarkdown documents generally. Here we want to point out that tables made using kable() are properly formatted for RMarkdown reports. Code and table rendered from RMarkdown document Similar to how we approached learning about making figures in R, we’ve demonstrated how to make good tables with a single example. The best way to really learn how to make tables is to practice using the tips here and playing around within R. So, feel free to use this as a start and go practice making a few beautiful tables in R! 8.0.6 Additional resources Karl Broman’s approach to tables in R knitr documentation kableExtra package documentation 8.0.7 Slides and Video Tables in R Slides "],["multiple-plots-in-r.html", "Chapter 9 Multiple Plots in R", " Chapter 9 Multiple Plots in R When generating reports for a data science project, there is often more than one plot that you want to display at a time. To accomplish this in R, we will use the R package patchwork from Thomas Lin Pedersen, which simplifies this process. 9.0.1 Installing patchwork As with other R packages you’ve used, you will first need to install this package. As this package is relatively new, however, it is not on CRAN so install.packages('patchwork') will not work. Instead, this package has to be installed using devtools. If you don’t have devtools installed yet, do that first. If you already have that library installed, you can simply load devtools and then install the patchwork package from GitHub. # install.packages(&quot;devtools&quot;) library(devtools) devtools::install_github(&quot;thomasp85/patchwork&quot;) 9.0.2 Basic plotting using patchwork Patchwork allows any plots generated from ggplot2 to be combined simply. For example, if you were interested in plotting data from the mtcars dataset in R but wanted to combine two different plots, you could use patchwork. Below, you’ll see code for combining two plots. The first plot examines the relationship between how many miles per gallon (mpg) a car a gets and the weight of that car in 1000lb (wt). This is assigned to object p1. The second plot looks at the relationship between how many mpgs a car gets and the number of forward gears that car has (p2). While you could plot each individually, you may want to see them side by side. With patchwork, you can do this my simply using a plus sign (p1+p2). Using this very simple code, you’ll obtain side by side plots, which is exactly what you were looking to achieve! library(ggplot2) library(patchwork) p1 &lt;- ggplot(mtcars) + geom_point(aes(wt, mpg)) p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, mpg, group = gear)) p1 + p2 Two plots side-by-side 9.0.3 Altering the layout If you don’t want these plots side-by-side, but rather one on top of the other, this can be controlled with plot_layout(), where you can define the number of columns (ncol) or number of rows (nrow) you would like to display. p1 + p2 + plot_layout(ncol = 1) two plots one on top of the other Similarly, if you want these on top of one another but would rather the first plot be larger, this can be controlled within plot_layout() using the heights argument. The ‘3’ in the code below specifies that you would like the top plot to be 3 times larger than the bottom plot (whose relative height is defined as ‘1’). p1 + p2 + plot_layout(ncol = 1, heights = c(3, 1)) two plots one on top of the other of unequal heights 9.0.4 Nesting plots Finally, sometimes you want a more complicated layout. Patchwork can handle this too. To nest a plot within another plot, the formatting is slightly more complicated, you can use parentheses ‘()’ or brackets ‘{}’ around the plots you want to nest. For example, in the code below, plot p4 is plotted first and the whole plot is defined to have one column. Then, plot p1 is added. Finally,p2 and p3 are combined into a single column plot before this combined plot (p2 + p3) is nested into the overall plot. The brackets {} are placed carefully around the plots to determine the achieve the desired plotting format. p3 &lt;- ggplot(mtcars) + geom_smooth(aes(disp, qsec)) p4 &lt;- ggplot(mtcars) + geom_bar(aes(carb)) p4 + ( p1 + ( p2 + p3 + plot_layout(ncol = 1) ) ) + plot_layout(ncol = 1) Nested Plots 9.0.5 Additional operators So far we have only added plots to one another using ‘+’. While this operator can accomplish most multi-plotting goals, we will briefly highlight a few additional operators within patchwork. 9.0.5.1 | and / If you are simply adding plots beside one another or on top of one another, this can be accomplished using | and /. | tells patchwork to put the plots next to one another from left to right. / tells patchwork you want those plots on top of each other. For example, below we see that p1, p2, and p3 should all be next to one another. These are grouped together because of the parentheses. Then these three plots should all be atop p4. (p1 | p2 | p3) / p4 Three plots together horizontally over another plot vertically 9.0.5.2 &amp; and * ggpplot2 allows for flexibility in theme in many different ways, as demonstrated in a previous lesson. To apply the same theme to all plots in the multi-plot image, you will want to use &amp;. Below you’ll see that with the use of &amp;, theme_bw has been applied to all the plots. p1 + (p2 + p3) + p4 + plot_layout(ncol = 1) &amp; theme_bw() All four plots changed to theme_bw() If you only wanted this theme to be applied to the plots in the current nesting level, you would use *. (p1 + (p2 + p3) + p4 + plot_layout(ncol = 1)) * theme_bw() Plots in main nesting level have theme_bw, but p2 and p3 remain unchanged 9.0.5.3 - Thus far, we have only focused on adding plots together using +. There is also an - operator. Think of this as a hyphen, rather than as a subtraction sign, because we won’t be removing any plots. This operator puts what is on the left and right side of the - on the same nesting level. In the code below, the overall plot layout defines that there should be one column. That means that p2 and p3 are on the same nesting level (because of the -). This forces p1 and p2 to be side by side. This operator is slightly less intuitive, and thus is included here for completeness but included at the end because you can likely compose all the multiplot images you need without fully understanding the - operator. p1 + p2 - p3 + plot_layout(ncol = 1) Using the - operator 9.0.6 Additional Resources Patchwork GitHub 9.0.7 Slides and Video Multiple Plots Slides "],["advanced-data-visualization.html", "Chapter 10 Advanced Data Visualization", " Chapter 10 Advanced Data Visualization So far in this course we’ve discussed the characteristics of good plots and tables as well as how to generate these using the statistical programming language R. The remainder of this course will build on what you have already learned, exposing you to a few additional tools that are to you for data visualization. The rest of this course is meant to expose you to the possibilities in R, not help you become an expert. However, after having an idea of the possibilities, we will provide links to other places where you can obtain more information, allow you to practice your data visualization skills on your own, and eventually become an expert at advanced data visualization. 10.0.1 Interactive Graphics Up to this point, all the graphics we’ve generated have been static graphics. Static graphics can certainly convey a lot of important information about data. However, they don’t react to user input. Nothing changes when you scroll over them. And, there is no way to adjust what is seen in the graphic after the static graphic is generate. On the other hand, interactive graphics allow users to interact with the information displayed. These graphics add an additional layer of information to the graphics we’ve previously generated in R. For example, an interactive graphic may allow the user to scroll over points on the plot and display information about that point. Or, it may allow the user to highlight a portion of the graph and zoom in on that part of the graph. Generally, if a graph changes in response to user input, it is an interactive graphic. 10.0.2 Animated Graphics Animated graphics are similar to interactive graphics in that they are not static. However, unlike interactive graphics – which respond to user input – animated graphics can generally be thought of as a number of static plots displayed one after another in a specific order in an animation. These are helpful when trying to display changes over time. 10.0.3 Advanced Graphics In R Both interactive and animated graphics can be generated in R. We’ll cover the basics below and will include additional resources that can be used to learn even more about generating these types of graphics in R. 10.0.3.1 plotly plotly can be used to “easily translate ggplot2 graphs to an interactive web-based version and/or create custom web-based visualizations directly from R.” plotly is its own framework that has been implemented to be usable in R through the plotly package 10.0.3.1.1 plotly interactive graphics Below, you see that p is a ggplot object. Here, we’re using a dataset with data from 150 different iris flowers. We’re looking at the petal length and petal width of these flowers, broken down by the species of the flower in the plot below. To take this static plot from ggplot (which we learned to generate earlier in this course), to an interactive plot, it only requires calling ggplotly(). ## Load libraries library(ggplot2) library(plotly) ## generate ggplot2 object p &lt;- ggplot(iris, aes(x = factor(Species), y = Petal.Length, color = Petal.Width)) + geom_boxplot() + geom_point() ## generate intreactive graphic p &lt;- ggplotly(p) p Within RStudio, ggplotly() graphs will display within the ‘Viewer’ tab. iris interactive plot in RStudio While this picture here appears to be static, within RStudio, you are able to interact with this graph. For example, if you hover over a point on the graph, information about that particular point will display. information about a specific point Similarly, if you hover your mouse over the boxplot, summary information about that category will display. information about a specific group of points If you hover over the graph in general, options will display at the top right of the interactive graph. hover over plot menu displays We won’t walk through each of these now, but if you hover your mouse over any of the icons in the menu, it will describe what that button does. The best way to get a feel for what these do is to play around with these options in RStudio and to read the plotly documentation hover over button in menu displays 10.0.3.1.2 plotly animated graphics In addition to general interactive graphics, plotly can also be used to generate animated plots - plots that show changes over time. The code for this is similar in form to what is seen above; however, it requires the frame argument be specified. This states what variable ggplotly should use for each frame in the animation. To demonstrate how this can be done, we’ll use a very common example data set, frequently used by R users. This dataset is from Jenny Bryan’s gapminder R package. It contains data about the life expectancy, population, and per capita GDP from a number of countries from 1952 to 2007. We will use these data to generate an animated graphic that shows the relationship between per capita GDP and life expectancy by country. Each point on the graph represents a different country. The points are colored by the continent that each country is from. As mentioned above, to generate an animated plot within plotly, frame must be specified. Below, frame is specified to be year, which specifies that the animation should cycle through the years within this dataset. ## install the package install.packages(&quot;gapminder&quot;) ## get the data data(gapminder, package = &quot;gapminder&quot;) ## generate ggplot object gg &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) + geom_point(aes(frame = year, ids = country)) + scale_x_log10() ## plot animated graphic ggplotly(gg) plotly animated graphic An important point is that this animated graphic is still an interactive graphic. For example, if we were only interested in looking at this relationship for countries in Africa and Europe, we could click on “Americas”, “Asia”, and “Oceania” in the legend to remove those points from the plot in the current view. plotly animated graphic is still interactive 10.0.3.1.3 plotly in RMarkdown reports plotly objects can be printed directly into RMarkdown reports (.Rmd files) as long as that .Rmd file is knit into an HTML document. If, however, a plotly object is knit in a non-HTML format, it will print simply as a .png screenshot of the graph. 10.0.3.2 gganimate With many things in R, there is more than one way to generate animated objects in RStudio. There is an additional package that allows for the generation of animated graphics from ggplot2 graphs: gganimate. Below we will generate the same graph as above but will use gganimate() to do so. The code to generate the ggplot object created (gg) will not change. The benefit of gganimate() is that if you are interesting in saving the image as a GIF, rather than embedding the plot into your .Rmd report, gganimate() has this capability. (gganimate() can save animated graphics as .gif, .mp4, .swf, and .html objects) ## download and load gganimate devtools::install_github(&quot;dgrtwo/gganimate&quot;) library(gganimate) ## plot animated graphic using gganimate gganimate(gg) ## to save this plot gganimate(gg, &quot;output.gif&quot;) {format: gif} 10.0.4 Additional resources plotly documentation gganimate documentation 10.0.5 Slides and Video Advanced Data Visualization Slides "],["data-visualization-1.html", "Chapter 11 Data Visualization", " Chapter 11 Data Visualization Throughout this course set, we’ll have a number of projects for you to complete. This is the second project of the course set. All of these will be included as Exercises. This means they will not be required to pass the course and receive your certificate; however, completing them will really help to improve your understanding of the material covered and to ensure that you’ve begun to master the skills needed to be a data scientist. In each project, we’ll aim to get you started and to ask questions that will help guide you through the project. But, we’ll intentionally leave pieces out where you have to figure out what needs to be done. This project will require you to: carry out an exploratory data analysis wrangle data generate exploratory plots generate explanatory plots You can access the project by going to the exercise accompanying this lesson. "],["data-visualization-project.html", "Chapter 12 Data Visualization Project", " Chapter 12 Data Visualization Project * If you would like to know the answers to the questions in this exercise, then you can take this course in Leanpub. Data Visualization is an incredibly important skill for a data scientist. Being able to generate exploratory visualizations that help you understand the data and explanatory visualizations so that your findings As such, this exercise has been generated to practice your, GitHub, terminal navigation, RStudio, and data wrangling skills. 12.0.1 GitHub Setup To get started, you’ll want to go to GitHub and start a new repository: Call this repository dataviz_project. Add a short description Check the box to “Initialize this repository with a README. Click Create Repository Once the repository has been created, Click on Clone or download and copy the “Clone with HTTPS” link provided. You’ll use this to clone your repo in RStudio Cloud. Note: If you’re stuck on this, these steps were covered in detail in an earlier course: Version Control. Refer to the materials in this course if you’re stuck on this part of the project. 12.0.2 RStudio Cloud Setup Go to the Cloud-based Data Science Space on RStudio Cloud Click on the “Projects” tab at the top of the workspace Make a copy of the project: dataviz_project In this project you should see a dataviz_project.Rmd file. You’ll use this to get started working on your project! Note: If you try to Knit this document at this time, you will get an error because there is code in this document that has to be edited (by you!) before it will be able to successfully knit! To start using version control, you’ll want to clone the GitHub repository you just created into this workspace. To do so, go to the Terminal and clone your project into this workspace. A new directory with the name of your GitHub repository should now be viewable in the Files tab of RStudio Cloud. You are now set up to track your project with git. 12.0.3 Data Science Project Setup As discussed previously, you’ll want all your data science projects you be organized from the very beginning. Let’s do that now! First, use cd to get yourself into the directory of your GitHub Project. Once in the correct directory, use mkdir in the terminal to create folders with the following structure: - data/ - raw_data/ - tidy_data/ - code/ - raw_code/ - final_code/ - figures/ - exploratory_figures/ - explanatory_figures/ - products/ - writing/ Now that your directories are set up you’ll want to use the Terminal (or ‘More’ drop-down menu in the Files tab) to move (mv) the dataviz_project.Rmd file into code/raw_code and the two .csv files in data/raw_data into the data/raw_data directory in your version controlled repository. This ensures that your code file and raw data are in the correct directory. Once the .Rmd document is in the correct folder, you’ll want to change the author of this document to your name at the top of the .Rmd document (in the YAML). Save this change before moving to the next step. Note: If you’re stuck on this, these steps were covered in detail in an earlier course: Organizing Data Science Projects. Refer to the materials in this course if you’re stuck on this part of the project. 12.0.4 Pushing to GitHub You’ll want to save changes to your project regularly by pushing them to GitHub. Now that you’ve got your file structure set up and have added a code file (.Rmd) and two raw data files (.csv), it’s a good time to stage, commit, and push these changes to GitHub. Do so now, and then take a long on GitHub to see the changes on their website! Note: If you’re stuck on this, these steps were covered in detail in an earlier course: Version Control. Refer to the materials in this course if you’re stuck on this part of the project. 12.0.5 Part 1: Exploratory Data Visualization The first part of the project will guide you through a few steps to read the data in and explore the data. After you have a sense of what data are included in the dataset, you’ll generate a number of exploratory plots. To get started, first run the code in the setup code chunk. This will install and load all packages you’ll need to complete this project. 12.0.5.1 The Data The data we’ll be using for this part of the project were downloaded from kaggle, and include information about “pet licenses issued by the Seattle Animal Shelter between 2005 and early 2017.” We’ll be exploring these data and generating a few exploratory plots in the first part of the project. To load the data in, run the code in the pet-data code chunk to create an object called pets. 12.0.5.2 Explore the Data Once the data have been read in, explore the data, adding your code to dataviz_project.Rmd, and then answer the following questions: How many pet licenses are included in the dataset? How many unique pet names are included in the dataset (animal_s_name) How many different species are included in this dataset (species)? Which species are included in the dataset? Now that you have a handle on the data, let’s start to generate some exploratory plots! 12.0.5.3 Visualize the Data To visualize the data, we’ll first guide you through a few code chunks that have partial code. After walking through these code chunks, you’ll be prompted to write code to generate your own exploratory plot! 12.0.5.3.1 Bar Chart: pet-barchart Start in the code chunk visualize-pets. Here you will see comments with partial code underneath of them. For example, the first plot you’ll want to generate will be using the comment from the partial code: ## visual breakdown of how many of each species ## are included in the dataset ggplot(DATASET) + geom_bar(aes(x=VARIABLE)) Here, you’ll have to change DATASET and VARIABLE in the code to the appropriate dataset and variable name in order to generate an exploratory plot. We’ll want species name along the x and a count of how many are in each species along the y. Feel free to customize your plots further using what you’ve learned about ggplot2! After generating this figure, you’ll be able to answer the following questions: Are there more dogs or cat licenses in this dataset? Approximately how many cat licenses are in this dataset? 12.0.5.3.2 Cat Table: pet-cat-table After generating this first bar chart, move onto the code chunk pet-cat-table. Here you’ll see the following partial code: ## Table: Most frequent Cat Name DATASET %&gt;% filter(species==&quot;SPECIES&quot;,VARIABLE != &quot;&quot;) %&gt;% group_by(VARIABLE) %&gt;% summarise(n=n()) %&gt;% arrange(-n) %&gt;% top_n(n=10) %&gt;% kable(., caption = &quot;Top 10 Cat Names in Seattle&quot;) Here, you will need to replace DATASET, \"SPECIES\", and VARIABLE (in two places) in order to get this code to run. Your table at the end should have information about the top 10 most frequent cat names - What is the most common cat name? 12.0.5.3.3 Dog Table: pet-dog-table Having successfully generated this table, move onto the pet-dog-table code chunk. There is no code in here. You’ll need to put all the necessary code in this code chunk! Here, the goal is to create a similar table to what we just created; however, this should contain the 10 most frequent dog names, rather than cat names. What is the most common dog name? 12.0.5.3.4 Line Chart: pet-linechart The last guided exploratory visualization you’ll see is in the code chunk pet-linechart. Here, the code to create two new columns has been provided in full. You’ll use the column ym, which creates a “year-month” variable, to generate your plot in just a second. You will, however, have to edit the partial code after ## how the number of licenses recorded has changed over time. Here, you’ll need to add the appropriate function_names to accomplish what is stated in the comment above the missing function name. Additionally, you’ll need to fill in the appropriate variable wherever you see VARIABLE. Finally, where you see geom_GEOM, change “GEOM” to the appropriate geom specified in the comment above. ## add date and ym columns pets &lt;- pets %&gt;% mutate(date = lubridate::ymd_hms(license_issue_date), ym = as.yearmon(pets$date, &quot;%y%m&quot;)) ## how the number of licenses recorded has changed over time pets %&gt;% ## group by yearmonth (`ym`) function_name(VARIABLE) %&gt;% ## count number within each group function_name(n=n()) %&gt;% ggplot(., aes(VARIABLE, n)) + ## geom name for line chart geom_GEOM() + scale_x_yearmon() + xlab(&quot;&quot;) + ylab(&quot;Number of licenses&quot;) After figuring out the missing pieces in the code and generating the plot, you’ll be able to answer the following questions: What does the function ymd_hms() accomplish? What geom did you specify to generate a line chart? In what year do you see a huge jump in the number of pet licenses? 12.0.5.3.5 Create Your Own Exploratory Plot: pet-plot After successfully generating two figures and two tables, it’s time for you to generate your own exploratory plot! Explore the data and generate an additional exploratory plot that helps you better understand the data in this dataset. Include the code for this in the pet-plot code chunk. 12.0.6 Pushing to GitHub You’ll want to save changes to your project regularly by pushing them to GitHub. Now that you’ve finished Part 1 of this project (yay!), it’s a good time to stage, commit, and push these changes to GitHub. Do so now, and then take a long on GitHub to see the changes on their website! Note: If you’re stuck on this, these steps were covered in detail in an earlier course: Version Control. Refer to the materials in this course if you’re stuck on this part of the project. 12.0.7 Part 2: Explanatory Data Visualization In the second part of the project, you’ll work to generate an explanatory plot. Building on what you’ve done above, here, we’ll again use ggplot2; however, we’ll focus on the details in the appearance of the plot we generate to ensure that we’re generating plots that effectively communicate the point we’re trying to make to others. 12.0.7.1 The Data The data used in this part of the project were dowloaded from FiveThirtyEight - steak-survey. They were originally used in the article: How Americans Like Their Steak. The goal of this part of the project will be to recreate the data visualization used in this article, which is re-printed here: steak survey data visualization from fivethirtyeight.com To get started, run the code in the meat-data code chunk to read the survey data into RStudio Cloud. 12.0.7.2 Explore the Data Once the data have been read in, explore the data. Add the code you use to explore the data to the meat-explore code chunk in dataviz_project.Rmd, and answer the following questions: How many people participated in the survey? How many people responded “Yes” to the question “Do you eat steak?” How many different (unique) responses were there to the question “How do you like your steak prepared?” 12.0.7.3 Wrangle the Data Run the code in the meat-wrangle code chunk to get the data in the right format for you to generate the plot. Once you’ve run the code, answer the following questions: What does the code within the mutate() function accomplish in this code chunk? What does the code within the filter() function accomplish in this code chunk? How many columns are there in pref? What is contained in the column: pref$prop? What is contained in the column: pref$n? 12.0.7.4 Visualize the Data To generate an explanatory figure, some of the code you’ll need has been entered into the meat-visualize code chunk. Work through this code line by line, replacing each function_name with the appropriate function to accomplish what the comment above the line states. For example, the first part of this code chunk contains the following partial code: ## generate the plot p &lt;- ggplot(pref) + ## specify you want to generate a bar chart function_name(aes(x = steak_pref, y = prop, fill = steak_pref), stat = &#39;identity&#39;, width = 0.7) Here, the comment says we want to ## specify you want to generate a bar chart. This says to me that I’ll want to change function_name to geom_bar, so that the code looks like this: ## generate the plot p &lt;- ggplot(pref) + ## specify you want to generate a bar chart geom_bar(aes(x = steak_pref, y = prop, fill = steak_pref), stat = &#39;identity&#39;, width = 0.7) After determining what function I need, I would then run that portion of the code (what you see above). Note that we’re assigning the plot to the object p. This means that to view the plot in the “Plots” tab you’ll have to type p into the Console and hit enter after you run the code above. This will display the plot in the “Plots” tab of RStudio Cloud. Work through this code layer by layer determining what function_name should be in each line of code. Note: function_name should be the only thing you have to change in this code. What function did you use to specify the colors of the bars in your bar chart? What does width = 0.7 accomplish in the code to generate the explanatory plot? (You can play around with the number to see how it changes the plot!) Without the line legend.position=\"none\" what would change on the plot? (Try removing that line of code and regenerating the plot to see what changes!) 12.0.7.5 Save the Plot Once you’ve worked through this code chunk and have a plot that looks very similar to the plot in the original publication (and that you see above), you’ll want to use ggsave() to save this plot to figures/explanatory_figures. Save this figure as “steak_R.png”. Do this using the partial code in the code chunk save-plot. 12.0.7.6 Create Your Own Exploratory Plot: meat-plot Now, you’ll want to generate an explanatory figure on your own. Use these data to generate a second explanatory plot. It should tell us something new about the data. You can use any column in the data frame. But, make sure that the figure is something that could be presented or shown to a boss. Add this code to meat-plot. A quick reminder, generating plots can take a while. Be patient as you make mistakes. Google and StackOverflow are your friends - use them when you’re stuck! 12.0.7.7 Save Your Explanatory plot After you’re happy with your very own explanatory plot, use ggsave() again to save this plot to figures/explanatory_figures. Be sure to use a filename other than “steak_R.png”. You don’t want to overwrite the plot you’ve already saved. Add this code to the code chunk save-meat-plot. 12.0.8 Add Markdown Text to .Rmd Before finalizing your project you’ll want be sure there are comments in your code chunks and text outside of your code chunks to explain what you’re doing in each code chunk. These explanations are incredibly helpful for someone who doesn’t code or someone unfamiliar to your project. Note: If you’re stuck on this, these steps were covered in detail in an earlier course: Introduction to R. Refer to the R Markdown lesson in this course if you’re stuck on this part (or the next part) of the project. 12.0.9 Knit your R Markdown Document Last but not least, you’ll want to Knit your .Rmd document into an HTML document. If you get an error, take a look at what the error says and edit your .Rmd document. Then, try to Knit again! Troubleshooting these error messages will teach you a lot about coding in R. 12.0.10 A Few Final Checks A complete project should have: Exploratory Analysis 3 plots (two guided ; one on your own) 2 tables (one guided ; one on your own) Explanatory Analysis 2 plots (one guided ; one on your own) saved to figures/explanatory_figures Markdown text explaining your project Comments in your code chunk Answered all questions throughout this exercise 12.0.11 Final push to GitHub Now that you’ve finalized your project, you’ll do one final push to GitHub. add, commit, and push your work to GitHub. Navigate to your GitHub repository, and answer the final question below! Note: If you’re stuck on this, these steps were covered in detail in an earlier course: Version Control. Refer to the materials in this course if you’re stuck on this part of the project. Congrats on finishing your Data Visualization Project!! "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor(s) FirstName LastName Lecturer(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved Delivered the course in some way - video or audio Content Author(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved If any other authors besides lead instructor Content Contributor(s) (include section name/link in parentheses) - make new line if more than one section involved Wrote less than a chapter Content Editor(s)/Reviewer(s) Checked your content Content Director(s) Helped guide the content direction Content Consultants (include chapter name/link in parentheses or word “General”) - make new line if more than one chapter involved Gave high level advice on content Acknowledgments Gave small assistance to content but not to the level of consulting Production Content Publisher(s) Helped with publishing platform Content Publishing Reviewer(s) Reviewed overall content and aesthetics on publishing platform Technical Course Publishing Engineer(s) Helped with the code for the technical aspects related to the specific course generation Template Publishing Engineers Candace Savonen, Carrie Wright Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Candace Savonen Package Developers (ottrpal) John Muschelli, Candace Savonen, Carrie Wright Art and Design Illustrator(s) Created graphics for the course Figure Artist(s) Created figures/plots for course Videographer(s) Filmed videos Videography Editor(s) Edited film Audiographer(s) Recorded audio Audiography Editor(s) Edited audio recordings Funding Funder(s) Institution/individual who funded course including grant number Funding Staff Staff members who help with funding   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.3 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2022-06-20 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.3) ## bookdown 0.24 2022-02-15 [1] Github (rstudio/bookdown@88bc4ea) ## callr 3.4.4 2020-09-07 [1] RSPM (R 4.0.2) ## cli 2.0.2 2020-02-28 [1] RSPM (R 4.0.0) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.14 2019-05-28 [1] RSPM (R 4.0.3) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.6.1 2022-01-22 [1] CRAN (R 4.0.2) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.0 2020-06-16 [1] RSPM (R 4.0.1) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## knitr 1.33 2022-02-15 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.0 2021-02-15 [1] CRAN (R 4.0.2) ## magrittr 2.0.2 2022-01-26 [1] CRAN (R 4.0.2) ## memoise 1.1.0 2017-04-21 [1] RSPM (R 4.0.0) ## ottrpal 0.1.2 2022-02-15 [1] Github (jhudsl/ottrpal@1018848) ## pillar 1.4.6 2020-07-10 [1] RSPM (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.3.4 2020-08-11 [1] RSPM (R 4.0.2) ## purrr 0.3.4 2020-04-17 [1] RSPM (R 4.0.3) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 0.4.10 2022-02-15 [1] Github (r-lib/rlang@f0c9be5) ## rmarkdown 2.10 2022-02-15 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.2 2020-11-15 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2022-02-15 [1] Github (R-lib/testthat@e99155a) ## tibble 3.0.3 2020-07-10 [1] RSPM (R 4.0.2) ## usethis 2.1.5.9000 2022-02-15 [1] Github (r-lib/usethis@57b109a) ## vctrs 0.3.4 2020-08-29 [1] RSPM (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2022-02-15 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["references.html", "Chapter 13 References", " Chapter 13 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
